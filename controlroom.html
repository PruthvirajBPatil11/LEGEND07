<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Baserow Traffic Watcher — Map of New Locations</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Inter, Arial, Helvetica, sans-serif; margin:12px; background:#f4f6f8; color:#111; }
    .wrap { max-width:1100px; margin:0 auto; }
    header { margin-bottom:10px; }
    #map { height:520px; border-radius:8px; box-shadow:0 8px 24px rgba(10,20,40,0.06); }
    .controls { display:flex; gap:12px; flex-wrap:wrap; margin:10px 0 16px; align-items:center; }
    .controls input[type="text"]{ padding:8px; border-radius:6px; border:1px solid #ddd; min-width:220px; }
    .controls input[type="number"]{ padding:8px; border-radius:6px; border:1px solid #ddd; width:110px; }
    .controls button{ padding:8px 12px; border-radius:8px; border:none; background:#0b74de; color:#fff; cursor:pointer }
    .controls button.secondary{ background:#666; }
    #locations { margin-top:14px; background:#fff; padding:12px; border-radius:8px; box-shadow:0 6px 18px rgba(0,0,0,0.04); }
    .location-row{ display:flex; align-items:center; justify-content:space-between; padding:8px 6px; border-bottom:1px solid #f0f0f0; }
    .location-info{ font-size:0.95rem; }
    .location-actions button{ margin-left:8px; padding:6px 8px; border-radius:6px; border:none; cursor:pointer }
    .toast{ position:fixed; right:18px; top:18px; background:#0b74de; color:#fff; padding:12px 14px; border-radius:8px; display:none; z-index:9999 }
    .toast.show{ display:block; animation:pop 320ms ease; }
    @keyframes pop { from { transform: translateY(-10px) scale(.98); opacity:0 } to { transform: translateY(0) scale(1); opacity:1 } }
    small.hint{ color:#666; display:block; margin-top:6px; font-size:0.9rem }
    pre.row-json{ margin:6px 0 0; font-size:0.85rem; white-space:pre-wrap; max-height:240px; overflow:auto; background:#fafafa; padding:8px; border-radius:6px; border:1px solid #f0f0f0 }
    .btn-small { padding:6px 8px; border-radius:6px; border:none; cursor:pointer; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h2>Baserow Traffic Watcher — Map new "lat of T" / "long of T"</h2>
      <p>Replace the Table ID and Database token below, then <strong>Start watching</strong>. New rows that contain <strong>"lat of T"</strong> and <strong>"long of T"</strong> (or other latitude/longitude fields) will be plotted and listed below with Remove / Focus buttons.</p>
    </header>

    <div class="controls" role="region" aria-label="controls">
      <input id="apiBase" type="text" value="https://api.baserow.io/api/database/rows/table" />
      <input id="tableId" type="text" value="674305" />
      <input id="token" type="text" value="QsQYhi1jNSzR0YroQunX3ZjJV4W9oja6" />
      <input id="interval" type="number" value="8" min="3" title="Polling interval in seconds" />
      <button id="startBtn">Start watching</button>
      <button id="stopBtn" class="secondary">Stop</button>
    </div>
    <small class="hint">Token must have read access. If you self-host, change API base to your instance (no trailing slash).</small>

    <div id="map"></div>

    <div id="locations" aria-live="polite">
      <h3 style="margin-top:0">New locations added (runtime)</h3>
      <div id="listContainer">
        <em>No new locations added yet.</em>
      </div>
    </div>

    <div style="margin-top:12px;">
      <h4>Debug / JSON of last fetched rows</h4>
      <pre id="debug" class="row-json">--</pre>
    </div>
  </div>

  <div id="toast" class="toast">new assignment added</div>

<!-- Dynamically load Leaflet if needed -->
<script>
function loadLeafletIfNeeded(cb) {
  if (window.L) { cb(); return; }

  const cssHref = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
  if (![...document.styleSheets].some(s => s.href && s.href.includes('leaflet'))) {
    const link = document.createElement('link');
    link.rel = 'stylesheet';
    link.href = cssHref;
    document.head.appendChild(link);
  }

  const scriptSrc = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
  const existing = [...document.scripts].find(s => s.src && s.src.includes('leaflet'));
  if (existing) {
    if (window.L) cb();
    else existing.addEventListener('load', ()=> cb());
    existing.addEventListener('error', ()=> console.error('Failed to load Leaflet from existing script tag.'));
    return;
  }

  const s = document.createElement('script');
  s.src = scriptSrc;
  s.onload = () => cb();
  s.onerror = () => console.error('Failed to load Leaflet script.');
  document.head.appendChild(s);
}

document.addEventListener('DOMContentLoaded', () => loadLeafletIfNeeded(startApp));

function startApp() {
  (function(){
    // elements
    const apiBaseInput = document.getElementById('apiBase');
    const tableIdInput = document.getElementById('tableId');
    const tokenInput = document.getElementById('token');
    const intervalInput = document.getElementById('interval');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const listContainer = document.getElementById('listContainer');
    const debugEl = document.getElementById('debug');
    const toast = document.getElementById('toast');

    // state
    let pollTimer = null;
    let seenIds = new Set();
    let markerMap = new Map(); // idStr -> marker
    let addedLocations = []; // {idStr, lat, lng, label}
    let map, markersLayer;

    function initMap() {
      if (map) return;
      map = L.map('map').setView([20.0, 78.0], 5);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '© OpenStreetMap contributors'
      }).addTo(map);
      markersLayer = L.layerGroup().addTo(map);
    }

    function showToastOnce() {
      toast.textContent = 'new assignment added';
      toast.classList.add('show');
      setTimeout(()=> toast.classList.remove('show'), 2800);
    }

    // Safely get numeric value from a field (handles numbers, strings, arrays, nested objects)
    function extractNumeric(v) {
      if (v === null || v === undefined) return NaN;
      if (typeof v === 'number') return v;
      if (typeof v === 'string') {
        // remove commas and trim
        const s = v.replace(/,/g, '').trim();
        // allow things like "18.5204" or "-73.9"
        if (/^-?\d+(\.\d+)?$/.test(s)) return parseFloat(s);
        // maybe it's a json string like "['18.5']" - try to parse
        try {
          const parsed = JSON.parse(s);
          return extractNumeric(parsed);
        } catch(e) { return NaN; }
      }
      if (Array.isArray(v)) {
        for (const el of v) {
          const n = extractNumeric(el);
          if (!Number.isNaN(n)) return n;
        }
        return NaN;
      }
      if (typeof v === 'object') {
        // check common keys
        const candidates = ['value','lat','lng','latitude','longitude','lon'];
        for (const k of candidates) if (k in v) {
          const n = extractNumeric(v[k]);
          if (!Number.isNaN(n)) return n;
        }
        // try all object values
        for (const kk of Object.keys(v)) {
          const n = extractNumeric(v[kk]);
          if (!Number.isNaN(n)) return n;
        }
        return NaN;
      }
      return NaN;
    }

    // Attempt to find lat & lng from a row object
    function findLatLngAndLabel(row) {
      const keys = Object.keys(row);
      let latKey = null, lngKey = null, labelKey = null;

      // try direct name matches first (case-insensitive)
      for (const k of keys) {
        const kn = k.toLowerCase();
        if (!latKey && (kn === 'lat of t' || (kn.includes('lat') && kn.includes('t')) || kn === 'lat' || kn === 'latitude')) latKey = k;
        if (!lngKey && (kn === 'long of t' || kn.includes('long') && kn.includes('t') || kn.includes('lng') || kn === 'long' || kn === 'longitude')) lngKey = k;
        if (!labelKey && (kn.includes('landmark') || kn.includes('name') || kn.includes('place') || kn.includes('label'))) labelKey = k;
      }

      // fallback: if lat or lng missing, try to find any numeric-looking fields
      if (!latKey || !lngKey) {
        const numericCandidates = keys.map(k => ({k, v: extractNumeric(row[k])})).filter(x => !Number.isNaN(x.v));
        if (numericCandidates.length >= 2) {
          // heuristics: take the pair with values in typical lat/lng ranges
          // lat range roughly [-90, 90], lng [-180,180]
          let found = {lat:null, lng:null};
          for (let i=0;i<numericCandidates.length;i++){
            for (let j=0;j<numericCandidates.length;j++){
              if (i===j) continue;
              const a = numericCandidates[i].v, b = numericCandidates[j].v;
              if (Math.abs(a) <= 90 && Math.abs(b) <= 180 && Math.abs(a) > Math.abs(b)) {
                // ambiguous — check both orders later
              }
              // pick first plausible pair where one falls in lat and other in lng
              if (Math.abs(a) <= 90 && Math.abs(b) <= 180) {
                found.lat = numericCandidates[i].k;
                found.lng = numericCandidates[j].k;
                latKey = found.lat; lngKey = found.lng;
                break;
              }
            }
            if (latKey && lngKey) break;
          }
          // if still not found, just take first two numeric fields
          if (!latKey || !lngKey) {
            if (numericCandidates[0] && numericCandidates[1]) {
              latKey = latKey || numericCandidates[0].k;
              lngKey = lngKey || numericCandidates[1].k;
            }
          }
        }
      }

      const lat = latKey ? extractNumeric(row[latKey]) : NaN;
      const lng = lngKey ? extractNumeric(row[lngKey]) : NaN;
      const label = labelKey ? (typeof row[labelKey] === 'string' ? row[labelKey] : JSON.stringify(row[labelKey])) : null;

      return { lat, lng, label, latKey, lngKey, labelKey };
    }

    function addMarkerForRow(row) {
      const idStr = (typeof row.id !== 'undefined' ? String(row.id) : JSON.stringify(row)).slice(0,100);
      if (markerMap.has(idStr)) return false; // already added

      const { lat, lng, label } = findLatLngAndLabel(row);
      if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
        console.warn('Skipping row (no valid lat/lng):', row.id, row);
        return false;
      }

      initMap();
      const marker = L.marker([lat, lng]);
      const popupContent = `<div><strong>Location</strong><br>Row ID: ${row.id ?? '(no id)'}<br>Lat: ${lat}<br>Lng: ${lng}${label ? `<br>Label: ${escapeHtml(label)}` : ''}</div>`;
      marker.bindPopup(popupContent);
      markersLayer.addLayer(marker);
      markerMap.set(idStr, marker);

      const labelDisplayed = label || `(${lat.toFixed(5)}, ${lng.toFixed(5)})`;
      addedLocations.push({ idStr, lat, lng, label: labelDisplayed, row });

      // create list item immediately so user can remove
      createListItemForLocation(idStr, labelDisplayed, lat, lng);
      fitMapToMarkers();
      return true;
    }

    function escapeHtml(s) {
      return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }

    function createListItemForLocation(idStr, label, lat, lng) {
      // remove "No new locations..." placeholder if present
      if (listContainer.children.length === 1 && listContainer.children[0].tagName === 'EM') listContainer.innerHTML = '';

      const div = document.createElement('div');
      div.className = 'location-row';
      div.id = `loc-${idStr}`;

      const info = document.createElement('div');
      info.className = 'location-info';
      info.innerHTML = `<strong>${escapeHtml(label)}</strong> &nbsp; <small>${lat.toFixed(5)}, ${lng.toFixed(5)}</small>`;

      const actions = document.createElement('div');
      actions.className = 'location-actions';

      const removeBtn = document.createElement('button');
      removeBtn.className = 'btn-small';
      removeBtn.style.background = '#e74c3c'; removeBtn.style.color = '#fff';
      removeBtn.textContent = 'Remove';
      removeBtn.addEventListener('click', ()=> {
        removeLocation(idStr);
      });

      const focusBtn = document.createElement('button');
      focusBtn.className = 'btn-small';
      focusBtn.style.background = '#2ecc71'; focusBtn.style.color = '#fff';
      focusBtn.textContent = 'Focus';
      focusBtn.addEventListener('click', ()=> {
        focusLocation(idStr);
      });

      actions.appendChild(removeBtn);
      actions.appendChild(focusBtn);
      div.appendChild(info);
      div.appendChild(actions);
      // prepend so newest is on top
      listContainer.prepend(div);
    }

    function focusLocation(idStr) {
      const m = markerMap.get(String(idStr));
      if (m) {
        map.setView(m.getLatLng(), Math.max(map.getZoom(), 14), {animate:true});
        m.openPopup();
      }
    }

    function removeLocation(idStr) {
      const m = markerMap.get(String(idStr));
      if (m) {
        markersLayer.removeLayer(m);
        markerMap.delete(String(idStr));
      }
      const el = document.getElementById(`loc-${idStr}`);
      if (el) el.remove();
      addedLocations = addedLocations.filter(it => it.idStr !== idStr);
    }

    function fitMapToMarkers() {
      const all = Array.from(markerMap.values());
      if (all.length === 0) return;
      const group = L.featureGroup(all);
      try { map.fitBounds(group.getBounds().pad(0.2), { animate: true, maxZoom: 16 }); } catch(e){}
    }

    async function fetchRows(apiBase, tableId, token) {
      const base = apiBase.replace(/\/+$/,'');
      const url = new URL(`${base}/${tableId}/`);
      url.searchParams.set('user_field_names', 'true');
      url.searchParams.set('page_size', '200');
      const res = await fetch(url.toString(), {
        headers: { 'Authorization': `Token ${token}`, 'Accept': 'application/json' }
      });
      if (!res.ok) {
        const txt = await res.text().catch(()=>res.statusText);
        throw new Error(`Baserow API error ${res.status}: ${txt}`);
      }
      const json = await res.json();
      if (Array.isArray(json)) return json;
      if (Array.isArray(json.results)) return json.results;
      return json;
    }

    async function pollOnce() {
      const apiBase = apiBaseInput.value.trim();
      const tableId = tableIdInput.value.trim();
      const token = tokenInput.value.trim();
      if (!apiBase || !tableId || !token) {
        showToast('Please set API base, table id, and token.');
        stopWatching();
        return;
      }

      try {
        const rows = await fetchRows(apiBase, tableId, token);
        debugEl.textContent = JSON.stringify(rows, null, 2);
        const arr = Array.isArray(rows) ? rows : (rows.results || []);
        const newRows = [];
        for (const r of arr) {
          const rid = (typeof r.id !== 'undefined') ? String(r.id) : JSON.stringify(r);
          if (!seenIds.has(rid)) {
            newRows.push(r);
            seenIds.add(rid);
          }
        }
        if (newRows.length > 0) {
          let addedCount = 0;
          for (const nr of newRows) {
            if (addMarkerForRow(nr)) addedCount++;
          }
          if (addedCount > 0) showToastOnce();
        }
      } catch (err) {
        console.error('Polling error', err);
        showToast(err.message || 'Error');
      }
    }

    function showToast(msg) {
      toast.textContent = msg;
      toast.classList.add('show');
      setTimeout(()=> toast.classList.remove('show'), 3000);
    }

    function startWatching() {
      if (pollTimer) return;
      const apiBase = apiBaseInput.value.trim();
      const tableId = tableIdInput.value.trim();
      const token = tokenInput.value.trim();
      if (!apiBase || !tableId || !token) {
        showToast('Please fill API base, table id, and token before starting.');
        return;
      }
      (async ()=>{
        try {
          const rows = await fetchRows(apiBase, tableId, token);
          const arr = Array.isArray(rows) ? rows : (rows.results || []);
          seenIds.clear();
          for (const r of arr) {
            const rid = (typeof r.id !== 'undefined') ? String(r.id) : JSON.stringify(r);
            seenIds.add(rid);
          }
          const intervalSec = Math.max(3, Number(intervalInput.value) || 8);
          pollTimer = setInterval(pollOnce, intervalSec * 1000);
          setTimeout(pollOnce, 700);
          showToast('Started watching table for new rows.');
        } catch (err) {
          showToast('Failed to start: ' + err.message);
        }
      })();
    }

    function stopWatching() {
      if (pollTimer) clearInterval(pollTimer);
      pollTimer = null;
      showToast('Stopped watching.');
    }

    startBtn.addEventListener('click', startWatching);
    stopBtn.addEventListener('click', stopWatching);
    [apiBaseInput, tableIdInput, tokenInput, intervalInput].forEach(inp => inp.addEventListener('keydown', e => { if (e.key === 'Enter') startWatching(); }));

    // initialize map area right away
    initMap();
  })();
}
</script>
</body>
</html>
